/* This file is part of vcube.
 *
 * Copyright (C) 2018 Andrew Skalski
 *
 * vcube is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * vcube is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with vcube.  If not, see <https://www.gnu.org/licenses/>.
 */

#define GENERATE_CONST_CUBES
namespace vcube {
	class cube;
	static cube *moves = 0;
	static cube *sym = 0;
	static int *sym_inv = 0;
	static int move_sym6[18][8];
}

#include <string>
#include <map>
#include "cube.h"

namespace vcube {
	cube S_URF3i, S_F2;
}

#include "cube6.h"

using namespace vcube;

/* Generates the file "const-cubes.h".  This setup should be done as a
 * constexpr function instead, but compilers currently do not support
 * SSE/AVX intrinsics within constexpr functions.
 */

std::string out(const cube &c) {
	std::string s(256, 0);
	auto u = reinterpret_cast<const uint64_t*>(&c);
	s.resize(sprintf(&s[0], "{0x%016lx,0x%08lx,0x%016lx}",
				u[2], u[1] & 0xffffffff, u[0]));
	return s;
}

int main() {
	S_URF3i = ~S_URF3;
	S_F2 = S_URF3 * S_U4 * S_U4 * S_URF3i;

	/* Symmetries */
	std::array<cube, 48> sym;
	sym[0] = {};
	sym[1] = S_LR2;
	for (int i =  2; i <  4; i++) sym[i] = S_F2   * sym[i -  2];
	for (int i =  4; i < 16; i++) sym[i] = S_U4   * sym[i -  4];
	for (int i = 16; i < 48; i++) sym[i] = S_URF3 * sym[i - 16];

	/* Find the inverse of all symmetries */
	std::array<uint8_t, 48> sym_inv;
	for (int i = 0; i < 48; i++) {
		for (int j = i; j < 48; j += 2) {
			if (sym[i].compose(sym[j], i & 1) == cube()) {
				sym_inv[i] = j;
				sym_inv[j] = i;
				break;
			}
		}
	}

	/* Moves */
	// Generate symmetries that map the U move to U, R, F, D, L, B
	std::array<cube, 6> face_sym;
	face_sym[0] = {};                                                   // U
	for (int i = 1; i < 3; i++) face_sym[i] = S_URF3 * face_sym[i - 1]; // R, F
	for (int i = 3; i < 6; i++) face_sym[i] = S_F2   * face_sym[i - 3]; // D, L, B

	// Use the symmetries to produce all 18 half-turn metric moves
	std::array<cube, 18> moves;
	for (int face = 0, i = 0; face < 6; face++, i += 3) {
		moves[i] = ~face_sym[face] * M_U * face_sym[face]; // M
		moves[i + 1] = moves[i] * moves[i];                // M2
		moves[i + 2] = moves[i] * moves[i + 1];            // M'
	}

	// 6-way move symmetry table (S_URF3 * inverse)
	std::map<cube, uint8_t> move_number;
	for (int m = 0; m < moves.size(); m++) {
		move_number[moves[m]] = m;
	}
	uint8_t move_sym6[18][6];
	for (int m = 0; m < 18; m++) {
		cube6 c6 = moves[m];
		for (int s = 0; s < 6; s++) {
			move_sym6[m][s] = move_number[c6[s]];
		}
	}

	/* Output the generated tables */
	puts("// Code generated by gen-const-cubes - DO NOT EDIT");
	puts("");

	puts("/* S_F2 - 180-degree rotation on F-B axis (z2) */");
	printf("static constexpr cube S_F2    = %s;\n\n", out(S_F2).c_str());

	puts("/* Inverse symmetries */");
	printf("static constexpr cube S_URF3i = %s;\n\n", out(S_URF3i).c_str());

	puts("/* Move table:");
	puts(" *   U, U2, U', R, R2, R', F, F2, F', D, D2, D', L, L2, L', B, B2, B'");
	puts(" */");
	printf("static constexpr std::array<cube, %ld> moves = {{\n", moves.size());
	for (auto &c : moves) {
		printf("\t%s,\n", out(c).c_str());
	}
	puts("}};");
	puts("");

	puts("/* Move 6-way symmetries (URF3 * Inverse) */");
	printf("static constexpr uint8_t move_sym6[%ld][8] = {\n", moves.size());
	for (int m = 0; m < 18; m++) {
		fputs("\t{", stdout);
		for (int i = 0; i < 6; i++) {
			printf(" %2d,", move_sym6[m][i]);
		}
		puts(" },");
	}
	puts("};");
	puts("");

	puts("/* Symmetries (0..47):");
	puts(" *   S_LR2  (0, 1)");
	puts(" *   S_F2   (0, 2)");
	puts(" *   S_U4   (0, 4, 8, 12)");
	puts(" *   S_URF3 (0, 16, 32)");
	puts(" */");
	printf("static constexpr std::array<cube, %ld> sym = {{\n", sym.size());
	for (auto &c : sym) {
		printf("\t%s,\n", out(c).c_str());
	}
	puts("}};");
	puts("");

	printf("/* Inverse symmetry map */\n");
	printf("static constexpr std::array<uint8_t, %ld> sym_inv = {\n", sym_inv.size());
	for (int i = 0; i < sym_inv.size(); i++) {
		putchar((i % 16) ? ' ' : '\t');
		printf("%2d,", sym_inv[i]);
		if (i % 16 == 15) {
			putchar('\n');
		}
	}
	puts("};");

	return 0;
}
